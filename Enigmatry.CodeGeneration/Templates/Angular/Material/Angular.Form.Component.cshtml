@using Enigmatry.CodeGeneration;
@using Enigmatry.CodeGeneration.Angular;
@using Enigmatry.CodeGeneration.Configuration.Form.Model
@using Enigmatry.CodeGeneration.Configuration.Form.Model.Select
@using Enigmatry.CodeGeneration.Templates.HtmlHelperExtensions.Angular;
@using Enigmatry.CodeGeneration.Templates.HtmlHelperExtensions.TypeScript
@model Enigmatry.CodeGeneration.Configuration.Form.FormComponentModel;
@inject CodeGeneratorOptions _options;
import { Component, EventEmitter, Input, OnInit, Output, TemplateRef } from '@@angular/core';
import { FormGroup } from '@@angular/forms';
import { FormlyFieldConfig } from '@@ngx-formly/core';
import { I@(Model.ComponentInfo.ModelType) } from '@_options.ApiClientTsImportPath';
import { IHideExpressionDictionary } from '@@enigmatry/angular-building-blocks/form';

@functions {

    void RenderControls(IEnumerable<FormControl> controls)
    {
        foreach (FormControl control in controls)
        {
            switch (control)
            {
                case FormControlGroup formControlGroup:
                    CreateFieldGroup(formControlGroup);
                    break;
                default:
                    CreateField(control);
                    break;
            }
        }
    }

    void CreateField(FormControl control)
    {
        var type = control.GetFormlyType();
        var readonlyType = control.GetReadonlyFormlyType();
        var typeString = string.Equals(type, readonlyType) ? $"'{type}'" : $"this.isReadonly ? '{readonlyType}' : '{type}'";

        @if (!control.IsVisible)
        {
        @:{ key: '@control.PropertyName' },
        return;
        }

        @:{
        @:key: '@control.PropertyName',
        @:type: @Html.Raw(typeString),
        @:className: '@Html.Raw(control.ClassName)',
        @:hideExpression: this.fieldsHideExpressions?.@(control.PropertyName) ?? false,
        CreateFieldTemplateOptions(control);
        CreateFieldValidationProperties(control);
        @:},
    }

    void CreateFieldTemplateOptions(FormControl control)
    {
        @:templateOptions: {
        @:label: @Html.Localize(control.LabelTranslationId, control.Label, _options.EnableI18N),
        @:placeholder: @Html.Localize(control.PlaceholderTranslationId, control.Placeholder, _options.EnableI18N),
        @:disabled: this.isReadonly || @control.IsReadonly.ToString().ToLower(),
        @:description: @Html.Localize(control.HintTranslationId, control.Hint, _options.EnableI18N),
        @:appearance: '@Html.Raw(control.GetAppearance())',
        @if (control is SelectFormControl select)
        {
            @:options: @Html.JsArray(select.FixedOptions, option => $"{{ value: {option.Value}, displayName: '{option.DisplayName}' }}"),
            @:valueProp: '@select.OptionValueKey',
            @:labelProp: '@select.OptionDisplayKey',

        }
        @:hidden: !@control.IsVisible.ToString().ToLower(),
        @if (control.ValidationRules.Any())
        {
            @Html.AddValidationTemplateOptions(control)
        }
        @:},
    }

    void CreateFieldValidationProperties(FormControl control)
    {
        @if (control.ValidationRules.Any(x => x.HasCustomMessage))
        {
            @:validation: {
            @:messages: {
            @Html.AddCustomValidationMessages(control, _options.EnableI18N)
            @:}
            @:},
        }
        @if (control.Validator != null)
        {
            @Html.AddModelOpetions(control)
            @Html.AddAsyncValidators(control)
        }
    }

    void CreateFieldGroup(FormControlGroup controlGroup)
    {
        var type = controlGroup.GetFormlyType();

        @:{
        @:type: '@Html.Raw(type)',
        @:fieldGroupClassName: '@Html.Raw(controlGroup.ClassName)',
        @:templateOptions: {
        @:label: @Html.Localize(controlGroup.LabelTranslationId, controlGroup.Label, _options.EnableI18N),
        @:placeholder: @Html.Localize(controlGroup.PlaceholderTranslationId, controlGroup.Placeholder, _options.EnableI18N),
        @:disabled: this.isReadonly || @controlGroup.IsReadonly.ToString().ToLower(),
        @:description: @Html.Localize(controlGroup.HintTranslationId, controlGroup.Hint, _options.EnableI18N)
        @:},
        @:fieldGroup:[
            RenderControls(controlGroup.FormControls);
        @:]
        @:},
    }
}

@@Component({
  selector: '@Model.AngularComponentSelector(_options.GeneratedComponentPrefix)',
  templateUrl: './@(Model.AngularComponentFileName()).html',
  styleUrls: ['./@(Model.AngularComponentFileName()).scss']
})
export class @Model.AngularComponentName() implements OnInit {

  @@Input() model: I@(Model.ComponentInfo.ModelType) = {} as I@(Model.ComponentInfo.ModelType);
  @@Input() set isReadonly(value: boolean) {
    this._isReadonly = value;
    this.fields = this.initializeFields();
  }
  get isReadonly() {
    return this._isReadonly;
  }

  @@Input() saveButtonText: string = 'Save';
  @@Input() cancelButtonText: string = 'Cancel';
  @@Input() formButtonsTemplate: TemplateRef@(Html.Raw("<any>")) | null | undefined;

  @@Input() fieldsHideExpressions: IHideExpressionDictionary<I@(Model.ComponentInfo.ModelType)> | undefined = undefined;

  @@Output() save = new EventEmitter@(Html.Raw($"<I{Model.ComponentInfo.ModelType}>"))();
  @@Output() cancel = new EventEmitter@(Html.Raw("<void>"))();

  _isReadonly: boolean;
  form = new FormGroup({});
  fields: FormlyFieldConfig[] = [];

  constructor() { }

  ngOnInit(): void {
    this.fields = this.initializeFields();
  }

  onSubmit() {
    if (this.form.valid) {
      this.save.emit(this.model);
    }
  }

  initializeFields(): FormlyFieldConfig[] {
    return [
        @{ RenderControls(Model.FormControls); }
    ];
  }
}