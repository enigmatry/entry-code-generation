@using Humanizer;
@using Enigmatry.CodeGeneration;
@using Enigmatry.CodeGeneration.Angular;
@using Enigmatry.CodeGeneration.Templates.HtmlHelperExtensions.Angular;
@using Enigmatry.CodeGeneration.Templates.HtmlHelperExtensions.TypeScript;
@model Enigmatry.CodeGeneration.Configuration.Form.FormComponentModel;
@inject CodeGeneratorOptions _options;
import { Component, EventEmitter, Input, OnInit, Output } from '@@angular/core';
import { FormGroup } from '@@angular/forms';
import { FormlyFieldConfig } from '@@ngx-formly/core';
import { I@(Model.ComponentInfo.ModelType) } from '@_options.ApiClientTsImportPath';
@if (Model.LookupService != null)
{
    @:import { map } from 'rxjs/operators';
    @:import { @(Model.ComponentInfo.Name)LookupService } from '../services/@(Model.AngularComponentDirectory())-generated-lookup.service';
}

@@Component({
  selector: '@Model.AngularComponentSelector(_options.GeneratedComponentPrefix)',
  templateUrl: './@(Model.AngularComponentFileName()).html',
  styleUrls: ['./@(Model.AngularComponentFileName()).scss']
})
export class @Model.AngularComponentName() implements OnInit {

  @@Input() model: I@(Model.ComponentInfo.ModelType) = {};
  @@Input() set isReadonly(value: boolean) {
    this._isReadonly = value;
    this.fields = this.initializeFields();
  }
  get isReadonly() {
    return this._isReadonly;
  }

@@Output() save = new EventEmitter@(Html.Raw($"<I{Model.ComponentInfo.ModelType}>"))();
  @@Output() cancel = new EventEmitter@(Html.Raw("<void>"))();

  _isReadonly: boolean;
  form = new FormGroup({});
  fields: FormlyFieldConfig[] = [];

  constructor(@if (Model.LookupService != null)
{<text>private lookupService: @(Model.ComponentInfo.Name)LookupService</text>}) {
    this.fields = this.initializeFields();
  }

  ngOnInit(): void {}

  onSubmit() {
    if (this.form.valid) {
      this.save.emit(this.model);
    }
  }

  initializeFields(): FormlyFieldConfig[] {
    return [
@foreach (var control in Model.VisibleFormControls)
{
    var type = control.GetFormlyFieldType();
    var readonlyType = control.GetReadonlyFormlyFieldType();
    var typeString = string.Equals(type, readonlyType) ? $"'{type}'" : $"this.isReadonly ? '{readonlyType}' : '{type}'";
    @:{
    @:key: '@control.PropertyName',
    @:type: @Html.Raw(typeString),
    @:templateOptions: {
        @:label: @Html.Localize(control.LabelTranslationId, control.Label, _options.EnableI18N),
        @:placeholder: @Html.Localize(control.PlaceholderTranslationId, control.Placeholder, _options.EnableI18N),
        @:disabled: this.isReadonly || @control.IsReadonly.ToString().ToLower(),
        @:description: @Html.Localize(control.HintTranslationId, control.Hint, _options.EnableI18N),
        @if (Model.OptionsAvailable(control))
        {
            @:options: this.lookupService.get@(control.PropertyName.Pascalize())$.pipe(
            @:map((arr) =>
            @:arr.map(el => el = {value: el.value, label: el.displayName}))
            @:),
        }
        @:hidden: !@control.IsVisible.ToString().ToLower(),
        @if (control.ValidationRules.Any())
        {
            @Html.AddValidationTemplateOptions(control)
        }
    @:},
    @if (control.ValidationRules.Any(x => x.HasCustomMessage))
    {
    @:validation: {
        @:messages: {
            @Html.AddCustomValidationMessages(control, _options.EnableI18N)
        @:}
    @:},
    }
    @if (control.Validators.Any())
    {
    @:asyncValidators: {
        @:validation: @Html.JsStringArray(control.Validators.Select(x => x.Camelize()))
    @:},
    }
    @:},
    }
    ];
  }
}
